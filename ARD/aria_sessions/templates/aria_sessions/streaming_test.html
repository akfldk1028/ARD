<!DOCTYPE html>
<html>
<head>
    <title>CACHE CLEARED v6 - Real-time 4-Camera Streaming</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .controls { margin: 20px 0; }
        .controls button { margin: 5px; padding: 10px 15px; }
        .status { margin: 10px 0; padding: 10px; background: #f0f0f0; }
        .frame-data { margin: 10px 0; padding: 10px; border: 1px solid #ccc; }
        .error { color: red; }
        .success { color: green; }
        #imagePreview { max-width: 400px; margin: 10px 0; }
        .stream-images { display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0; }
        .stream-image { border: 1px solid #ddd; padding: 10px; max-width: 300px; }
        .stream-image img { max-width: 100%; height: auto; }
        .stream-image h4 { margin: 0 0 5px 0; }
    </style>
</head>
<body>
    <h1>Aria Real-time Streaming Test</h1>
    
    <div class="controls">
        <h3>Camera Streaming:</h3>
        <button onclick="startSimpleStreaming()">Start Real-time Streaming</button>
        <button onclick="stopSimpleStreaming()">Stop Streaming</button>
        <button onclick="getSingleFrame()">Get Single Frame</button>
    </div>
    
    <div class="controls">
        <h3>Sensor Streaming:</h3>
        <button class="btn stream-btn" onclick="startSensorStream('imu-right')" style="background: linear-gradient(45deg, #9C27B0, #7B1FA2);">🧭 IMU Right</button>
        <button class="btn stream-btn" onclick="startSensorStream('imu-left')" style="background: linear-gradient(45deg, #9C27B0, #7B1FA2);">🧭 IMU Left</button>
        <button class="btn stream-btn" onclick="startSensorStream('magnetometer')" style="background: linear-gradient(45deg, #FF5722, #D84315);">🧲 자력계</button>
        <button class="btn stream-btn" onclick="startSensorStream('barometer')" style="background: linear-gradient(45deg, #607D8B, #455A64);">🌡️ 기압계</button>
        <button class="btn stream-btn" onclick="startSensorStream('microphone')" style="background: linear-gradient(45deg, #FFC107, #FF8F00);">🎵 마이크</button>
        <button class="btn stream-btn" onclick="startSensorStream('gps')" style="background: linear-gradient(45deg, #4CAF50, #388E3C);">📍 GPS</button>
        <button class="btn stream-btn" onclick="startSensorStream('wps')" style="background: linear-gradient(45deg, #2196F3, #1976D2);">📶 WPS</button>
        <button class="btn stream-btn" onclick="startSensorStream('bluetooth')" style="background: linear-gradient(45deg, #3F51B5, #303F9F);">📱 블루투스</button>
    </div>
    
    <div class="controls">
        <label>Session ID: 
            <select id="sessionId">
                <option value="">Select a session...</option>
            </select>
            <button onclick="loadSessions()">Refresh Sessions</button>
        </label>
        <br><br>
        <label>FPS: <input type="number" id="fps" value="2" min="1" max="30"></label>
        <label>Max Frames: <input type="number" id="maxFrames" value="20" min="1" max="100"></label>
    </div>
    
    <div id="status" class="status">Ready to connect</div>
    <div id="frameCount" class="status">Frames received: 0</div>
    
    <div id="latestFrame" class="frame-data">
        <h3>Latest Frame:</h3>
        <div id="frameInfo">No frame data</div>
        <img id="imagePreview" style="display: none;">
    </div>
    
    <div id="streamingImages" class="frame-data">
        <h3>Real-time Multi-Camera Streaming:</h3>
        <div id="streamImages" class="stream-images">
            <div class="stream-image" id="stream-camera-rgb">
                <h4>RGB Camera</h4>
                <img src="" alt="RGB">
                <div class="image-info">Waiting...</div>
            </div>
            <div class="stream-image" id="stream-camera-slam-left">
                <h4>SLAM Left</h4>
                <img src="" alt="SLAM Left">
                <div class="image-info">Waiting...</div>
            </div>
            <div class="stream-image" id="stream-camera-slam-right">
                <h4>SLAM Right</h4>
                <img src="" alt="SLAM Right">
                <div class="image-info">Waiting...</div>
            </div>
            <div class="stream-image" id="stream-camera-eyetracking">
                <h4>Eye Tracking</h4>
                <img src="" alt="Eye Tracking">
                <div class="image-info">Waiting...</div>
            </div>
        </div>
    </div>
    
    <div id="sensorData" class="frame-data">
        <h3>Real-time Sensor Data (All 12 Sensors):</h3>
        <div class="stream-images">
            <div class="stream-image" id="stream-imu-right">
                <h4>IMU Right</h4>
                <div class="sensor-data">
                    <div>Accel: <span id="imu-right-accel">0, 0, 0</span> m/s²</div>
                    <div>Gyro: <span id="imu-right-gyro">0, 0, 0</span> rad/s</div>
                    <div>Temp: <span id="imu-right-temp">0</span>°C</div>
                </div>
            </div>
            <div class="stream-image" id="stream-imu-left">
                <h4>IMU Left</h4>
                <div class="sensor-data">
                    <div>Accel: <span id="imu-left-accel">0, 0, 0</span> m/s²</div>
                    <div>Gyro: <span id="imu-left-gyro">0, 0, 0</span> rad/s</div>
                    <div>Temp: <span id="imu-left-temp">0</span>°C</div>
                </div>
            </div>
            <div class="stream-image" id="stream-magnetometer">
                <h4>Magnetometer (mag0)</h4>
                <div class="sensor-data">
                    <div>Mag: <span id="mag-field">0, 0, 0</span> T</div>
                    <div>Temp: <span id="mag-temp">0</span>°C</div>
                </div>
            </div>
            <div class="stream-image" id="stream-barometer">
                <h4>Barometer (baro0)</h4>
                <div class="sensor-data">
                    <div>Pressure: <span id="baro-pressure">0</span> Pa</div>
                    <div>Temp: <span id="baro-temp">0</span>°C</div>
                </div>
            </div>
            <div class="stream-image" id="stream-microphone">
                <h4>Microphone (mic)</h4>
                <div class="sensor-data">
                    <div>Blocks: <span id="mic-blocks">0</span></div>
                    <div>Samples: <span id="mic-samples">0</span></div>
                    <div>Channels: <span id="mic-channels">0</span></div>
                </div>
            </div>
            <div class="stream-image" id="stream-gps">
                <h4>GPS</h4>
                <div class="sensor-data">
                    <div>Lat: <span id="gps-lat">0.0</span>°</div>
                    <div>Lon: <span id="gps-lon">0.0</span>°</div>
                    <div>Alt: <span id="gps-alt">0.0</span>m</div>
                </div>
            </div>
            <div class="stream-image" id="stream-wps">
                <h4>WPS</h4>
                <div class="sensor-data">
                    <div>Status: <span id="wps-status">-</span></div>
                    <div>Data: <span id="wps-data">-</span></div>
                </div>
            </div>
            <div class="stream-image" id="stream-bluetooth">
                <h4>Bluetooth</h4>
                <div class="sensor-data">
                    <div>Status: <span id="bt-status">-</span></div>
                    <div>Data: <span id="bt-data">-</span></div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="log" style="height: 300px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px;"></div>
    
    <script>
        let streamingInterval = null;
        let frameCount = 0;
        let currentFrameIndex = 0;
        let isStreaming = false;
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : (type === 'success' ? 'success' : '');
            logDiv.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function startSimpleStreaming() {
            const sessionId = document.getElementById('sessionId').value;
            
            if (isStreaming) {
                log('Already streaming', 'error');
                return;
            }
            
            isStreaming = true;
            currentFrameIndex = 0;  // 카운터 리셋
            document.getElementById('status').textContent = 'Real-time Streaming Started';
            log('Starting real-time streaming...', 'success');
            
            // Meta 공식 메모리 캐시 패턴: 한번 로드 → 좌르르륽 스트리밍
            streamingInterval = setInterval(() => {
                loadSimultaneousData(sessionId);
            }, 50);  // 50ms마다 (20fps) - 메모리 캐시라서 매우 빠름
        }
        
        function handleMessage(data) {
            switch(data.type) {
                case 'connection':
                    log(`Connected to session: ${data.session_id}`, 'success');
                    break;
                    
                case 'streaming_started':
                    log(`Streaming started - Total frames: ${data.total_frames}`, 'success');
                    frameCount = 0;
                    break;
                    
                case 'frame_data':
                    frameCount++;
                    document.getElementById('frameCount').textContent = `Frames received: ${frameCount}`;
                    
                    // 최신 프레임 정보 표시
                    const frameInfo = `
                        Frame: ${data.frame_number}<br>
                        Stream: ${data.stream_label}<br>
                        Sensor: ${data.sensor_type}<br>
                        Timestamp: ${data.timestamp}ns
                    `;
                    document.getElementById('frameInfo').innerHTML = frameInfo;
                    
                    // 실시간 이미지 표시
                    if (data.data && data.data.image_data_base64) {
                        displayStreamingImage(data.stream_label, data.data.image_data_base64, data.data.image_shape);
                    }
                    
                    log(`Frame ${data.frame_number}: ${data.stream_label} @ ${data.timestamp}ns`);
                    break;
                    
                case 'single_frame':
                    const frameData = data.data;
                    if (frameData.image_base64) {
                        const img = document.getElementById('imagePreview');
                        img.src = `data:image/jpeg;base64,${frameData.image_base64}`;
                        img.style.display = 'block';
                        log(`Single frame loaded: ${frameData.stream_name} ${frameData.image_shape}`, 'success');
                    }
                    break;
                    
                case 'streaming_completed':
                    log(`Streaming completed - Total frames sent: ${data.total_frames_sent}`, 'success');
                    break;
                    
                case 'streaming_stopped':
                    log('Streaming stopped', 'success');
                    break;
                    
                case 'error':
                    log(`Error: ${data.message}`, 'error');
                    break;
                    
                default:
                    log(`Unknown message type: ${data.type}`);
            }
        }
        
        function startStreaming() {
            if (!socket) {
                log('Please connect first', 'error');
                return;
            }
            
            const fps = parseInt(document.getElementById('fps').value);
            const maxFrames = parseInt(document.getElementById('maxFrames').value);
            
            const config = {
                command: 'start_streaming',
                streams: ['camera-rgb', 'camera-slam-left', 'camera-slam-right'],
                fps: fps,
                max_frames: maxFrames,
                include_images: true
            };
            
            socket.send(JSON.stringify(config));
            log('Starting streaming...');
        }
        
        function stopStreaming() {
            if (!socket) return;
            
            socket.send(JSON.stringify({
                command: 'stop_streaming'
            }));
        }
        
        function getFrame() {
            if (!socket) {
                log('Please connect first', 'error');
                return;
            }
            
            socket.send(JSON.stringify({
                command: 'get_frame',
                stream: 'camera-rgb',
                frame: 0
            }));
            
            log('Requesting single frame...');
        }
        
        function loadMultiCameraFrames(sessionId) {
            // 🏆 메모리 캐시에서 단일 프레임 로드 (디스크 I/O 없음)
            log('Loading from MEMORY CACHE (no disk I/O)...', 'success');
            
            const frameIdx = Math.floor(Math.random() * 123);  // 랜덤 프레임 (0-122)
            
            // 4개 카메라별로 메모리 캐시 API 호출
            const cameras = ['camera-rgb', 'camera-slam-left', 'camera-slam-right', 'camera-et'];
            
            cameras.forEach(camera => {
                fetch(`/api/v1/aria-sessions/memory-cached-frame/?stream=${camera}&frame=${frameIdx}`)
                .then(response => {
                    if (response.ok) {
                        const frameIdx = response.headers.get('X-Frame-Idx');
                        const streamLabel = response.headers.get('X-Stream-Label');
                        const source = response.headers.get('X-Source');
                        const shape = response.headers.get('X-Shape');
                        
                        return response.blob();
                    } else if (response.status === 400) {
                        throw new Error('Memory cache not loaded');
                    } else if (response.status === 204) {
                        throw new Error('No content in cache');
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                })
                .then(blob => {
                    const streamDiv = document.getElementById(`stream-${camera}`);
                    if (streamDiv) {
                        const img = streamDiv.querySelector('img');
                        const info = streamDiv.querySelector('.image-info');
                        
                        // 이전 URL 정리
                        if (img.dataset.oldUrl) {
                            URL.revokeObjectURL(img.dataset.oldUrl);
                        }
                        
                        const url = URL.createObjectURL(blob);
                        img.src = url;
                        img.style.display = 'block';
                        img.dataset.oldUrl = url;
                        
                        // 정보 업데이트
                        info.textContent = `Memory Cache Frame ${frameIdx} (${camera})`;
                    }
                })
                .catch(error => {
                    const streamDiv = document.getElementById(`stream-${camera}`);
                    if (streamDiv) {
                        const info = streamDiv.querySelector('.image-info');
                        info.textContent = `${error.message}`;
                    }
                });
            });
            
            frameCount++;
            document.getElementById('frameCount').textContent = `Memory Cache Frames: ${frameCount}`;
            document.getElementById('frameInfo').innerHTML = `Multi-Camera Memory Cache<br>Status: Fast Memory Access (No Disk I/O)`;
        }
        
        function loadLatestFrame(sessionId) {
            // 단일 프레임 로드 (Get Single Frame 버튼용)
            loadMultiCameraFrames(sessionId);
        }
        
        function stopSimpleStreaming() {
            if (streamingInterval) {
                clearInterval(streamingInterval);
                streamingInterval = null;
            }
            isStreaming = false;
            
            // 최적화된 스트리밍 중지
            fetch('/api/v1/aria-sessions/stop-optimized-streaming/', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'}
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    log(`🛑 Optimized streaming stopped: ${data.message}`, 'success');
                }
            })
            .catch(err => log(`Failed to stop optimized streaming: ${err}`, 'error'));
            
            document.getElementById('status').textContent = 'OPTIMIZED Streaming Stopped';
            log('🛑 OPTIMIZED streaming stopped', 'success');
        }
        
        function getSingleFrame() {
            const sessionId = document.getElementById('sessionId').value;
            
            if (!sessionId || sessionId === '') {
                log('No session selected - using auto-selected session...', 'success');
            }
            
            loadLatestFrame(sessionId);
        }
        
        function startSensorStream(sensorType) {
            const sessionId = document.getElementById('sessionId').value;
            
            if (!sessionId || sessionId === '') {
                log('No session selected - using auto-selected session...', 'success');
            }
            
            log(`Starting ${sensorType} sensor streaming...`, 'success');
            
            // 센서 데이터 폴링 시작
            if (window.sensorInterval) {
                clearInterval(window.sensorInterval);
            }
            
            window.sensorInterval = setInterval(() => {
                loadSensorData(sessionId, sensorType);
            }, 500);  // 500ms 간격
        }
        
        function loadSimultaneousData(sessionId) {
            // Meta Official Memory Cache Pattern: Load Once → Fast Streaming
            
            currentFrameIndex = (currentFrameIndex + 1) % 123;  // VRS has 123 frames
            
            // Use working general streaming API
            let apiUrl = `/api/v1/aria-sessions/unified-stream-realtime/?sample=${currentFrameIndex}&max_samples=1`;
            
            // Call unified streaming API
            fetch(apiUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                
                const { images = [], sensors = [] } = data.unified_data;
                
                // Process image data
                let imageProcessed = 0;
                images.forEach((imageData, index) => {
                    try {
                        updateImageDisplay(imageData);
                        imageProcessed++;
                    } catch (error) {
                        log(`ERROR processing image ${index}: ${error.message}`, 'error');
                    }
                });
                
                // Process sensor data
                let sensorProcessed = 0;
                sensors.forEach((sensorData, index) => {
                    try {
                        updateSensorDisplay(sensorData);
                        sensorProcessed++;
                    } catch (error) {
                        log(`ERROR processing sensor ${index}: ${error.message}`, 'error');
                    }
                });
                
                // Update statistics
                frameCount++;
                const stats = data.stats || {};
                document.getElementById('frameCount').textContent = 
                    `Memory Cache: ${frameCount} (Images: ${stats.image_count || 0}, Sensors: ${stats.sensor_count || 0})`;
                document.getElementById('frameInfo').innerHTML = `
                    Memory Cache Frame: ${currentFrameIndex}<br>
                    Status: Fast Memory Access (No Disk I/O)<br>
                    Cache Hits: ${stats.cache_hits || 0}<br>
                    Processed: ${imageProcessed} images, ${sensorProcessed} sensors<br>
                    Method: ${data.method || 'memory_cache'}
                `;
                
            })
            .catch(error => {
                log(`Memory cache streaming error: ${error.message}`, 'error');
                
                // Update info even on error
                document.getElementById('frameInfo').innerHTML = `
                    Error at frame ${currentFrameIndex}<br>
                    Status: ERROR - ${error.message}<br>
                    Suggestion: Check if memory cache is preloaded
                `;
            });
        }
        
        function updateImageDisplay(imageData) {
            // 이미지 스트림별 표시 업데이트 (유지보수 개선)
            const streamMapping = {
                'camera-rgb': 'stream-camera-rgb',
                'camera-slam-left': 'stream-camera-slam-left', 
                'camera-slam-right': 'stream-camera-slam-right',
                'camera-et': 'stream-camera-eyetracking'
            };
            
            const streamId = streamMapping[imageData.stream_label];
            const streamDiv = document.getElementById(streamId);
            
            if (!streamDiv) {
                log(`WARNING: Stream div not found for ${imageData.stream_label}`, 'error');
                return;
            }
            
            const img = streamDiv.querySelector('img');
            const info = streamDiv.querySelector('.image-info');
            
            if (!img || !info) {
                log(`WARNING: Image elements not found in ${streamId}`, 'error');
                return;
            }
            
            // Base64 이미지 데이터 확인
            if (!imageData.image_base64) {
                log(`WARNING: No base64 data for ${imageData.stream_label}`, 'error');
                info.textContent = 'No image data';
                return;
            }
            
            try {
                // 이전 URL 정리 (메모리 누수 방지)
                if (img.dataset.oldUrl) {
                    URL.revokeObjectURL(img.dataset.oldUrl);
                }
                
                // Base64 이미지 설정
                img.src = `data:image/jpeg;base64,${imageData.image_base64}`;
                img.style.display = 'block';
                img.onerror = () => {
                    log(`ERROR: Failed to load image for ${imageData.stream_label}`, 'error');
                    info.textContent = 'Image load failed';
                };
                img.onload = () => {
                    log(`SUCCESS: Loaded image for ${imageData.stream_label} (${imageData.image_shape})`, 'success');
                };
                
                // 정보 업데이트 (Memory Cache)
                const timestamp = new Date(imageData.timestamp_ns / 1000000).toLocaleTimeString();
                const shape = imageData.shape ? `${imageData.shape.join('x')}` : 'unknown';
                info.textContent = `${shape} | Frame: ${imageData.frame_idx} | ${timestamp} | Source: ${imageData.data_source}`;
                
            } catch (error) {
                log(`ERROR: Exception in updateImageDisplay for ${imageData.stream_label}: ${error}`, 'error');
                info.textContent = `Error: ${error.message}`;
            }
        }
        
        function updateSensorDisplay(sensorData) {
            // 실제 VRS 센서 데이터로 UI 업데이트 - 모든 센서 지원
            const label = sensorData.stream_label;
            const timestamp = new Date(sensorData.device_timestamp_ns / 1000000).toLocaleTimeString();
            
            if (label === 'imu-right' && sensorData.imu) {
                // IMU Right 데이터 (null 체크 추가)
                const imu = sensorData.imu;
                const accel = imu.accelerometer || {x: 0, y: 0, z: 0};
                const gyro = imu.gyroscope || {x: 0, y: 0, z: 0};
                
                document.getElementById('imu-right-accel').textContent = 
                    `${(accel.x || 0).toFixed(3)}, ${(accel.y || 0).toFixed(3)}, ${(accel.z || 0).toFixed(3)}`;
                document.getElementById('imu-right-gyro').textContent = 
                    `${(gyro.x || 0).toFixed(4)}, ${(gyro.y || 0).toFixed(4)}, ${(gyro.z || 0).toFixed(4)}`;
                document.getElementById('imu-right-temp').textContent = 
                    (imu.temperature && imu.temperature.value !== null) ? imu.temperature.value.toFixed(1) : 'N/A';
                
                log(`Real IMU-Right: accel=[${(accel.x || 0).toFixed(3)}, ${(accel.y || 0).toFixed(3)}, ${(accel.z || 0).toFixed(3)}] @ ${timestamp}`);
                
            } else if (label === 'imu-left' && sensorData.imu) {
                // IMU Left 데이터 (null 체크 추가)
                const imu = sensorData.imu;
                const accel = imu.accelerometer || {x: 0, y: 0, z: 0};
                const gyro = imu.gyroscope || {x: 0, y: 0, z: 0};
                
                document.getElementById('imu-left-accel').textContent = 
                    `${(accel.x || 0).toFixed(3)}, ${(accel.y || 0).toFixed(3)}, ${(accel.z || 0).toFixed(3)}`;
                document.getElementById('imu-left-gyro').textContent = 
                    `${(gyro.x || 0).toFixed(4)}, ${(gyro.y || 0).toFixed(4)}, ${(gyro.z || 0).toFixed(4)}`;
                document.getElementById('imu-left-temp').textContent = 
                    (imu.temperature && imu.temperature.value !== null) ? imu.temperature.value.toFixed(1) : 'N/A';
                
                log(`Real IMU-Left: accel=[${(accel.x || 0).toFixed(3)}, ${(accel.y || 0).toFixed(3)}, ${(accel.z || 0).toFixed(3)}] @ ${timestamp}`);
                
            } else if (label === 'mag0' && sensorData.magnetometer) {
                // 자력계 데이터 (null 체크 추가)
                const mag = sensorData.magnetometer;
                const field = mag.magnetic_field || {x: 0, y: 0, z: 0};
                
                document.getElementById('mag-field').textContent = 
                    `${(field.x || 0).toFixed(8)}, ${(field.y || 0).toFixed(8)}, ${(field.z || 0).toFixed(8)}`;
                document.getElementById('mag-temp').textContent = 
                    (mag.temperature && mag.temperature.value !== null) ? mag.temperature.value.toFixed(1) : 'N/A';
                
                log(`Real Magnetometer: mag=[${(field.x || 0).toFixed(8)}, ${(field.y || 0).toFixed(8)}, ${(field.z || 0).toFixed(8)}] @ ${timestamp}`);
                
            } else if (label === 'baro0' && sensorData.barometer) {
                // 기압계 데이터 (null 체크 추가)
                const baro = sensorData.barometer;
                document.getElementById('baro-pressure').textContent = 
                    (baro.pressure && baro.pressure.value !== null) ? baro.pressure.value.toFixed(0) : '0';
                document.getElementById('baro-temp').textContent = 
                    (baro.temperature && baro.temperature.value !== null) ? baro.temperature.value.toFixed(1) : 'N/A';
                
                log(`Real Barometer: pressure=${(baro.pressure && baro.pressure.value !== null) ? baro.pressure.value.toFixed(0) : '0'} Pa @ ${timestamp}`);
                
            } else if (label === 'mic' && sensorData.audio) {
                // 마이크/오디오 데이터
                const audio = sensorData.audio;
                document.getElementById('mic-blocks').textContent = audio.num_blocks || 0;
                document.getElementById('mic-samples').textContent = audio.sample_info ? audio.sample_info.total_samples : 0;
                document.getElementById('mic-channels').textContent = audio.sample_info ? audio.sample_info.channels : 0;
                
                log(`Real Microphone: ${audio.num_blocks} blocks, ${audio.sample_info ? audio.sample_info.total_samples : 0} samples @ ${timestamp}`);
                
            } else if (label === 'gps' && sensorData.gps) {
                // GPS 데이터 (null 체크 추가)
                const gps = sensorData.gps;
                const location = gps.location || {latitude: 0, longitude: 0, altitude: 0};
                
                document.getElementById('gps-lat').textContent = (location.latitude || 0).toFixed(6);
                document.getElementById('gps-lon').textContent = (location.longitude || 0).toFixed(6);
                document.getElementById('gps-alt').textContent = (location.altitude || 0).toFixed(1);
                
                log(`Real GPS: lat=${location.latitude || 0}, lon=${location.longitude || 0} @ ${timestamp}`);
                
            } else if (label === 'wps' && sensorData.wps) {
                // WPS 데이터 (실제 구조 반영)
                const wps = sensorData.wps;
                document.getElementById('wps-status').textContent = wps.status || 'Active';
                document.getElementById('wps-data').textContent = wps.signal_info ? 
                    `Networks: ${wps.signal_info.networks}, Strength: ${wps.signal_info.strength}` : 
                    `Seq: ${sensorData.sequence}`;
                
                log(`Real WPS: status=${wps.status}, networks=${wps.signal_info ? wps.signal_info.networks : 0} @ ${timestamp}`);
                
            } else if (label === 'bluetooth' && sensorData.bluetooth) {
                // 블루투스 데이터 (실제 구조 반영)
                const bt = sensorData.bluetooth;
                document.getElementById('bt-status').textContent = bt.status || 'Active';
                document.getElementById('bt-data').textContent = bt.connection_info ? 
                    `Devices: ${bt.connection_info.devices}, State: ${bt.connection_info.connection_state}` : 
                    `Seq: ${sensorData.sequence}`;
                
                log(`Real Bluetooth: status=${bt.status}, devices=${bt.connection_info ? bt.connection_info.devices : 0} @ ${timestamp}`);
            } else {
                // 알 수 없는 센서
                log(`Unknown sensor: ${label} - ${sensorData.sensor_type} @ ${timestamp}`);
            }
        }
        
        function loadSensorData(sessionId, sensorType) {
            // Memory Cache 센서 스트리밍 (버튼용)
            log(`Loading sensor data from MEMORY CACHE for ${sensorType}...`, 'success');
            
            if (window.sensorInterval) {
                clearInterval(window.sensorInterval);
            }
            
            let sensorIndex = 0;
            window.sensorInterval = setInterval(() => {
                // Memory Cache 센서 API 사용 (디스크 I/O 없음)
                let apiUrl = `/api/v1/aria-sessions/memory-cached-sensors/?sensors=${sensorType}&sensor=${sensorIndex}`;
                
                // 센서별 메모리 캐시 API 호출
                fetch(apiUrl)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    if (data.sensor_data && data.sensor_data.length > 0) {
                        // 최신 센서 데이터 표시
                        const latestSensor = data.sensor_data[data.sensor_data.length - 1];
                        updateSensorDisplay(latestSensor);
                        log(`Memory Cache Sensor ${sensorType}: index ${sensorIndex}`, 'success');
                    }
                    
                    sensorIndex = (sensorIndex + 1) % 100;  // 센서 인덱스 순환
                })
                .catch(error => {
                    log(`Memory Cache Sensor ${sensorType} error: ${error.message}`, 'error');
                });
                
            }, 200);  // 200ms마다 센서 데이터 업데이트 (5fps) - 메모리라서 빠름
        }
        
        // 세션 목록 로드
        function loadSessions() {
            log('Loading available sessions...');
            
            fetch('/api/v1/aria-sessions/simple/')
                .then(response => response.json())
                .then(data => {
                    const selectElement = document.getElementById('sessionId');
                    selectElement.innerHTML = '<option value="">Select a session...</option>';
                    
                    if (data.results && data.results.length > 0) {
                        data.results.forEach(session => {
                            const option = document.createElement('option');
                            option.value = session.session_id;
                            option.textContent = `${session.session_id.substring(0, 8)}... (${session.status})`;
                            selectElement.appendChild(option);
                        });
                        log(`Loaded ${data.results.length} sessions`, 'success');
                        
                        // 첫 번째 세션 자동 선택
                        if (data.results.length > 0) {
                            selectElement.value = data.results[0].session_id;
                        }
                    } else {
                        log('No sessions found', 'error');
                    }
                })
                .catch(error => {
                    log(`Failed to load sessions: ${error}`, 'error');
                });
        }
        
        // 페이지 로드 시 자동으로 세션 목록 로드
        window.onload = function() {
            // URL에서 session ID 추출 (기존 기능 유지)
            const params = new URLSearchParams(window.location.search);
            const sessionId = params.get('session');
            
            if (sessionId) {
                // URL에 세션 ID가 있으면 직접 설정
                const selectElement = document.getElementById('sessionId');
                const option = document.createElement('option');
                option.value = sessionId;
                option.textContent = sessionId;
                selectElement.appendChild(option);
                selectElement.value = sessionId;
                log(`Session loaded from URL: ${sessionId}`, 'success');
            } else {
                // URL에 세션 ID가 없으면 목록 로드
                loadSessions();
            }
        };
    </script>
</body>
</html>