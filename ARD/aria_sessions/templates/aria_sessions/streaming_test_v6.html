<!DOCTYPE html>
<html>
<head>
    <title>CACHE BYPASSED v6 - 4-Camera Memory Cache Streaming</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .controls { margin: 20px 0; }
        .controls button { margin: 5px; padding: 10px 15px; }
        .status { margin: 10px 0; padding: 10px; background: #f0f0f0; }
        .frame-data { margin: 10px 0; padding: 10px; border: 1px solid #ccc; }
        .error { color: red; }
        .success { color: green; }
        #imagePreview { max-width: 400px; margin: 10px 0; }
        .stream-images { display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0; }
        .stream-image { border: 1px solid #ddd; padding: 10px; max-width: 300px; }
        .stream-image img { max-width: 100%; height: auto; }
        .stream-image h4 { margin: 0 0 5px 0; }
    </style>
</head>
<body>
    <h1>NEW v6 - Aria 4-Camera Memory Cache Streaming</h1>
    
    <div class="controls">
        <h3>4-Camera Memory Cache Streaming:</h3>
        <button onclick="startSimpleStreaming()">Start Memory Cache Streaming</button>
        <button onclick="stopSimpleStreaming()">Stop Streaming</button>
        <button onclick="getSingleFrame()">Get Single Frame</button>
    </div>
    
    <div id="status" class="status">Ready - Memory Cache Pattern</div>
    <div id="frameCount" class="status">Frames received: 0</div>
    
    <div id="streamingImages" class="frame-data">
        <h3>Real-time 4-Camera Streaming (Memory Cache):</h3>
        <div id="streamImages" class="stream-images">
            <div class="stream-image" id="stream-camera-rgb">
                <h4>RGB Camera</h4>
                <img src="" alt="RGB">
                <div class="image-info">Waiting...</div>
            </div>
            <div class="stream-image" id="stream-camera-slam-left">
                <h4>SLAM Left</h4>
                <img src="" alt="SLAM Left">
                <div class="image-info">Waiting...</div>
            </div>
            <div class="stream-image" id="stream-camera-slam-right">
                <h4>SLAM Right</h4>
                <img src="" alt="SLAM Right">
                <div class="image-info">Waiting...</div>
            </div>
            <div class="stream-image" id="stream-camera-eyetracking">
                <h4>Eye Tracking</h4>
                <img src="" alt="Eye Tracking">
                <div class="image-info">Waiting...</div>
            </div>
        </div>
    </div>
    
    <div id="log" style="height: 300px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px;"></div>
    
    <script>
        let streamingInterval = null;
        let frameCount = 0;
        let currentFrameIndex = 0;
        let isStreaming = false;
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : (type === 'success' ? 'success' : '');
            logDiv.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function startSimpleStreaming() {
            if (isStreaming) {
                log('Already streaming', 'error');
                return;
            }
            
            log('Step 1: Loading VRS to memory cache...', 'success');
            document.getElementById('status').textContent = 'Loading VRS to Memory...';
            
            // 1단계: VRS 데이터를 메모리에 로드
            fetch('/api/v1/aria-sessions/preload-vrs-to-memory/', {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    log(`Step 2: VRS loaded to memory (${data.cache_stats.total_frames} frames)`, 'success');
                    
                    // 2단계: 메모리에서 스트리밍 시작
                    isStreaming = true;
                    currentFrameIndex = 0;
                    document.getElementById('status').textContent = 'Memory Cache Streaming Started';
                    log('Step 3: Starting memory cache streaming...', 'success');
                    
                    streamingInterval = setInterval(() => {
                        loadSimultaneousData();
                    }, 500);  // 500ms (2fps) - 안정적인 속도
                } else {
                    throw new Error(data.message || 'Failed to load cache');
                }
            })
            .catch(error => {
                log(`Memory cache load failed: ${error.message}`, 'error');
                document.getElementById('status').textContent = 'Cache Load Failed';
            });
        }
        
        function stopSimpleStreaming() {
            if (streamingInterval) {
                clearInterval(streamingInterval);
                streamingInterval = null;
            }
            isStreaming = false;
            document.getElementById('status').textContent = 'Memory Cache Streaming Stopped';
            log('Memory cache streaming stopped', 'success');
        }
        
        function getSingleFrame() {
            loadSimultaneousData();
        }
        
        function loadSimultaneousData() {
            // Meta Official Memory Cache Pattern: Load Once → Fast Streaming
            currentFrameIndex = (currentFrameIndex + 1) % 312;  // RGB has 312 frames in memory
            
            // Use MEMORY CACHE API (no disk I/O)
            let apiUrl = `/api/v1/aria-sessions/memory-cached-stream/?frame=${currentFrameIndex}`;
            
            fetch(apiUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // DEBUG: API 응답 구조 확인
                console.log('API Response:', data);
                
                const { images = [], sensors = [] } = data.unified_data;
                
                // Process image data
                let imageProcessed = 0;
                images.forEach((imageData, index) => {
                    try {
                        updateImageDisplay(imageData);
                        imageProcessed++;
                    } catch (error) {
                        log(`ERROR processing image ${index}: ${error.message}`, 'error');
                    }
                });
                
                // Update statistics
                frameCount++;
                const stats = data.stats || {};
                document.getElementById('frameCount').textContent = 
                    `Memory Cache: ${frameCount} (Images: ${stats.image_count || 0})`;
                
            })
            .catch(error => {
                log(`Memory cache streaming error: ${error.message}`, 'error');
            });
        }
        
        function updateImageDisplay(imageData) {
            const streamMapping = {
                'camera-rgb': 'stream-camera-rgb',
                'camera-slam-left': 'stream-camera-slam-left', 
                'camera-slam-right': 'stream-camera-slam-right',
                'camera-et': 'stream-camera-eyetracking'
            };
            
            const streamId = streamMapping[imageData.stream_label];
            const streamDiv = document.getElementById(streamId);
            
            if (!streamDiv) {
                log(`WARNING: Stream div not found for ${imageData.stream_label}`, 'error');
                return;
            }
            
            const img = streamDiv.querySelector('img');
            const info = streamDiv.querySelector('.image-info');
            
            if (!img || !info) {
                log(`WARNING: Image elements not found in ${streamId}`, 'error');
                return;
            }
            
            if (!imageData.image_base64) {
                log(`WARNING: No base64 data for ${imageData.stream_label}`, 'error');
                info.textContent = 'No image data';
                return;
            }
            
            try {
                // 이전 URL 정리 (메모리 누수 방지)
                if (img.dataset.oldUrl) {
                    URL.revokeObjectURL(img.dataset.oldUrl);
                }
                
                // Base64 이미지 설정
                img.src = `data:image/jpeg;base64,${imageData.image_base64}`;
                img.style.display = 'block';
                img.onerror = () => {
                    log(`ERROR: Failed to load image for ${imageData.stream_label}`, 'error');
                    info.textContent = 'Image load failed';
                };
                img.onload = () => {
                    log(`SUCCESS: Loaded image for ${imageData.stream_label}`, 'success');
                };
                
                // 정보 업데이트 (메모리 캐시 필드명)
                const timestamp = new Date(imageData.timestamp_ns / 1000000).toLocaleTimeString();
                const shape = imageData.shape ? `${imageData.shape.join('x')}` : 'unknown';
                const frameIdx = imageData.frame_idx;
                const source = imageData.data_source;
                info.textContent = `${shape} | Frame: ${frameIdx} | ${timestamp} | ${source}`;
                
            } catch (error) {
                log(`ERROR: Exception in updateImageDisplay for ${imageData.stream_label}: ${error}`, 'error');
                info.textContent = `Error: ${error.message}`;
            }
        }
        
        window.onload = function() {
            log('Memory cache streaming page loaded v6', 'success');
        };
    </script>
</body>
</html>